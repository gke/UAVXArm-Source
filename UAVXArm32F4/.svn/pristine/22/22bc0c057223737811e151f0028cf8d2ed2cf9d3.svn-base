//#define USE_LCD
#if defined(USE_LCD)

#include "UAVX.h"

void LCDClear(void);
void LCDCursor(uint8 col, uint8 row);

uint16 intPowerMeterSum, intPowerTrigger1;

#define DEBUG false

boolean ACC, MAG, BARO, LOG_VALUES, MULTILINE_POST, LCD_TELEMETRY, POWERMETER,
		VBAT, BUZZER, OLED_I2C_128x64LOGO_PERMANENT;
uint8 NUMBER_MOTOR;
boolean EnablePage[10];
int8 telemetry;
int16 rcData[16];
int16 gyroData[3];
int16 accSmooth[16];
uint32 cycleTimeMin, cycleTimeMax, cycleTime, armedTime;
uint16 i2c_errors_count, failsafeEvents, annex650_overrun_count, failsafeCnt;
int16 BAROaltMax, BAROaltStart, BaroAlt;
int16 vbat;
boolean conf;

#define VBATLEVEL1_3S 1
#define VBATREF 1

#define LCD_BAUD_RATE 9600

#define MAX_PARAMS 64
#define BOXARM 1
#define VERSION 1

#define LCDPIN_ON
#define LCDPIN_OFF
#define PINMODE_LCD

#define MULTILINE_PRE 0
#define MULTILINE_POST 0

#define PLEVELDIVSOFT 1

#define LAT 0
#define LON 1

int32 GPS_coord[2];
uint8 GPS_numSat;

int16 motor[16];
int16 servo[16];

int16 angle[3];

int16 rcOptions[16];

#define MAXCHECK 100
#define MINCHECK -100

uint8 PRI_SERVO_FROM, PRI_SERVO_TO, SEC_SERVO_FROM, SEC_SERVO_TO;

#define acc_1G 1

uint8 key;

unsigned int __bss_end;
unsigned int __heap_start;
void *__brkval;

enum zzz {
	ROLL, PITCH, YAW, THROTTLE
};
enum LCDCommands {
	LCD_MENU_PREV,
	LCD_MENU_UP,
	LCD_MENU_DOWN,
	LCD_MENU_NEXT,
	LCD_MENU_SAVE_EXIT,
	LCD_MENU_ABORT,
	LCD_VALUE_UP,
	LCD_VALUE_DOWN
};

enum LCDTypes {
	LCD_SERIAL3W, LCD_TEXTSTAR, LCD_VT100, LCD_ETPP, LCD_LCD03, OLED_I2C_128x64
};

const uint8 LCDType = LCD_ETPP;

void Insert(char * l, int32 v, uint8 len) {
	uint8 i;

	for (i = len; i > 0; i--) {
		l[i] = '0' + v % 10;
		v /= 10;
	}
}

uint8 pgm_read_byte(uint8 * s) {
	return (s);
}

uint16 pgm_read_word(const void * const s) {
	return (s);
}

int16 readRawRC(uint8 c) {
	return (0);
}

boolean isBuzzerON(void) {
	return (false);
}

void blinkLED(uint8 a, uint8 b, uint8 c) {
}

char L[2][17];

//______________________________________________________________________________________________

// LCD Config

static uint8 lcdStickState[3];
#define IsLow(x)  (lcdStickState[x] & 0x1)
#define IsHigh(x) (lcdStickState[x] & 0x2)
#define IsMid(x)  (!lcdStickState[x])

const void * const lcd_param_ptrable[64];

//______________________________________________________________________________________________

// OLED

#define OLED_address   0x3C     // OLED at address 0x3C in 7bit
char LINE_FILL_STRING[] = "                      "; // Used by clear_OLED() 128 bits / 6 bytes = 21 chars per row
uint8 CHAR_FORMAT = 0; // use to INVERSE characters
// use INVERSE    CHAR_FORMAT = 0b01111111;
// use NORMAL     CHAR_FORMAT = 0;
static char buffer; // buffer to read bytes from ROM, using pgm_read_byte macro. NB! avr/pgmspace.h must be included prog_uchar LOGO[] = {  // My first attempt to flash a logo....
const uint8 LOGO[] = { // logo....
		0x00, 0x00, 0x02, 0xFE, 0xFE, 0x0E, 0xFC, 0xF8, 0xC0, 0x00, 0xC0, 0xF8,
				0xFC, 0x0E, 0xFE, 0xFE, 0xFE, 0x02, 0x00, 0x00, 0x30, 0xF0,
				0xF0, 0x00, 0x00, 0x00, 0x30, 0xF0, 0xF0, 0x00, 0x00, 0x00,
				0x02, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x30, 0xF8, 0xFE, 0x30,
				0x30, 0x30, 0x00, 0x00, 0x30, 0xF6, 0xF6, 0x00, 0x00, 0x00,
				0x02, 0x06, 0x1E, 0xFE, 0xFE, 0xC2, 0x00, 0xC2, 0xFE, 0x7E,
				0xFE, 0xC2, 0x00, 0xC2, 0xFE, 0xFE, 0x3E, 0x06, 0x02, 0x00,
				0x30, 0xF6, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x30, 0xF6, 0xF6,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F,
				0x1F, 0x10, 0x00, 0x83, 0x9F, 0x9F, 0x9F, 0x83, 0x80, 0x90,
				0x9F, 0x9F, 0x9F, 0x10, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x18,
				0x18, 0x18, 0x0C, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x10, 0x1F,
				0x1F, 0x10, 0x00, 0x80, 0x80, 0x8F, 0x9F, 0x98, 0x9E, 0x8F,
				0x80, 0x80, 0x90, 0x1F, 0x1F, 0x10, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x07, 0x1F, 0x1E, 0x1F, 0x03, 0x00, 0x07, 0x1F,
				0x1E, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x1F,
				0x1F, 0x10, 0x00, 0x00, 0x00, 0x10, 0x1F, 0x1F, 0x10, 0x00,
				0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x80,
				0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0x3C, 0x0E, 0x07,
				0x03, 0x03, 0x01, 0x81, 0xC1, 0xC1, 0xC1, 0xC1, 0x81, 0x01,
				0x03, 0x03, 0x07, 0x0E, 0x3C, 0xF8, 0xE0, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF8, 0x3C, 0x0E, 0x07,
				0x03, 0x03, 0x01, 0x81, 0xC1, 0xC1, 0xC1, 0xC1, 0x81, 0x01,
				0x03, 0x03, 0x07, 0x0E, 0x3C, 0xF8, 0xE0, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x06, 0x3E, 0xF8, 0xC0, 0xFC, 0x0E, 0xFC, 0xC0, 0xF8, 0x3E,
				0x06, 0x00, 0xFE, 0xFE, 0x00, 0x06, 0xFF, 0xFF, 0x86, 0x86,
				0x00, 0xFF, 0xFF, 0x0C, 0x06, 0x06, 0xFE, 0xFC, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x1F, 0x7F, 0xF0, 0xC0, 0x80, 0x00, 0x00,
				0x00, 0x07, 0x0F, 0x0C, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00,
				0x80, 0xC0, 0xF0, 0x7F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x1F, 0x7F, 0xF0, 0xC0, 0x80, 0x00, 0x00,
				0x00, 0x07, 0x0F, 0x0C, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00,
				0x80, 0xC0, 0xF0, 0x7F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xC0, 0xC0,
				0xC1, 0xC1, 0x80, 0x80, 0x00, 0x01, 0x01, 0x00, 0x00, 0xC0,
				0xC1, 0xC1, 0xC0, 0xC0, 0xC0, 0xC1, 0xC1, 0xC1, 0x80, 0x01,
				0x01, 0x00, 0x00, 0x00, 0x81, 0x81, 0xC0, 0xC0, 0xC0, 0xC0,
				0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07, 0x06, 0x06,
				0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x03, 0x03, 0x01,
				0x03, 0x07, 0x0E, 0x1C, 0x38, 0xF0, 0xE0, 0xE0, 0xF0, 0x38,
				0x1C, 0x0E, 0x07, 0x03, 0x01, 0x03, 0x03, 0x07, 0x06, 0x06,
				0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x03, 0x03, 0x01,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0xFC, 0xFE, 0xFF, 0x07, 0x03, 0x01, 0x01, 0xE1, 0xE1, 0xE1,
				0xE3, 0xE7, 0xE7, 0xE6, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
				0x71, 0x71, 0x71, 0x71, 0x7B, 0x7F, 0x3F, 0x1F, 0x00, 0x00,
				0x00, 0x0F, 0x1F, 0x3F, 0x39, 0x71, 0x71, 0x71, 0xE3, 0xE7,
				0xE7, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x80, 0xC0, 0xE0, 0x70, 0x30, 0x38, 0x18, 0x18, 0x18, 0x18,
				0x18, 0x18, 0x18, 0x18, 0x38, 0x30, 0x70, 0xE0, 0xF0, 0xB8,
				0x1C, 0x0E, 0x07, 0x03, 0x01, 0x01, 0x03, 0x07, 0x0E, 0x1C,
				0xB8, 0xF0, 0xE0, 0x70, 0x30, 0x38, 0x18, 0x18, 0x18, 0x18,
				0x18, 0x18, 0x18, 0x18, 0x38, 0x30, 0x70, 0xE0, 0xC0, 0x80,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x07, 0x0F, 0x0E, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x0E, 0x0F,
				0x0F, 0x07, 0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F,
				0x0F, 0x1E, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x0F, 0x0F, 0x07,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xFC, 0xCC, 0xCC, 0xFC,
				0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFE, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xFC, 0xCC, 0xCC, 0xFC,
				0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFE, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x04,
				0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x10, 0xE0, 0x00, 0x00,
				0x80, 0x40, 0x20, 0x20, 0x20, 0x40, 0x80, 0x00, 0x60, 0x80,
				0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0xF0, 0x08, 0x04, 0x04,
				0x04, 0x08, 0xF0, 0x00, 0x00, 0xE0, 0x5C, 0x44, 0x44, 0x44,
				0x84, 0x04, 0x00, 0x00, 0x10, 0x08, 0x04, 0x04, 0x04, 0x8C,
				0x70, 0x00, 0x00, 0x30, 0x48, 0x84, 0x84, 0x84, 0x48, 0x30,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1C, 0x38,
				0x30, 0x70, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
				0x70, 0x30, 0x38, 0x1C, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1C, 0x38,
				0x30, 0x70, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
				0x70, 0x30, 0x38, 0x1C, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x20, 0x20, 0x20,
				0x20, 0x20, 0x20, 0x10, 0x08, 0x07, 0x00, 0x00, 0x0F, 0x12,
				0x22, 0x22, 0x22, 0x12, 0x0B, 0x00, 0x00, 0x01, 0x0E, 0x30,
				0x0E, 0x01, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x20, 0x10,
				0x0F, 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x0F,
				0x00, 0x00, 0x20, 0x30, 0x28, 0x24, 0x22, 0x21, 0x20, 0x00,
				0x00, 0x0E, 0x11, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, 0x00,
				0x00, 0x00

		};

const uint8 myFont[][6] = { // Refer to "Times New Roman" Font Database... 5 x 7 font
		{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, { 0x00, 0x00, 0x4F, 0x00, 0x00,
				0x00 }, //   (  1)  ! - 0x0021 Exclamation Mark
				{ 0x00, 0x07, 0x00, 0x07, 0x00, 0x00 }, //   (  2)  " - 0x0022 Quotation Mark
				{ 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00 }, //   (  3)  # - 0x0023 Number Sign
				{ 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00 }, //   (  4)  $ - 0x0024 Dollar Sign
				{ 0x23, 0x13, 0x08, 0x64, 0x62, 0x00 }, //   (  5)  % - 0x0025 Percent Sign
				{ 0x36, 0x49, 0x55, 0x22, 0x50, 0x00 }, //   (  6)  & - 0x0026 Ampersand
				{ 0x00, 0x05, 0x03, 0x00, 0x00, 0x00 }, //   (  7)  ' - 0x0027 Apostrophe
				{ 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00 }, //   (  8)  ( - 0x0028 Left Parenthesis
				{ 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00 }, //   (  9)  ) - 0x0029 Right Parenthesis
				{ 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00 }, //   ( 10)  * - 0x002A Asterisk
				{ 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00 }, //   ( 11)  + - 0x002B Plus Sign
				{ 0x00, 0x50, 0x30, 0x00, 0x00, 0x00 }, //   ( 12)  , - 0x002C Comma
				{ 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 }, //   ( 13)  - - 0x002D Hyphen-Minus
				{ 0x00, 0x60, 0x60, 0x00, 0x00, 0x00 }, //   ( 14)  . - 0x002E Full Stop
				{ 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 }, //   ( 15)  / - 0x002F Solidus
				{ 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00 }, //   ( 16)  0 - 0x0030 Digit Zero
				{ 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00 }, //   ( 17)  1 - 0x0031 Digit One
				{ 0x42, 0x61, 0x51, 0x49, 0x46, 0x00 }, //   ( 18)  2 - 0x0032 Digit Two
				{ 0x21, 0x41, 0x45, 0x4B, 0x31, 0x00 }, //   ( 19)  3 - 0x0033 Digit Three
				{ 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00 }, //   ( 20)  4 - 0x0034 Digit Four
				{ 0x27, 0x45, 0x45, 0x45, 0x39, 0x00 }, //   ( 21)  5 - 0x0035 Digit Five
				{ 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00 }, //   ( 22)  6 - 0x0036 Digit Six
				{ 0x01, 0x71, 0x09, 0x05, 0x03, 0x00 }, //   ( 23)  7 - 0x0037 Digit Seven
				{ 0x36, 0x49, 0x49, 0x49, 0x36, 0x00 }, //   ( 24)  8 - 0x0038 Digit Eight
				{ 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00 }, //   ( 25)  9 - 0x0039 Dight Nine
				{ 0x00, 0x36, 0x36, 0x00, 0x00, 0x00 }, //   ( 26)  : - 0x003A Colon
				{ 0x00, 0x56, 0x36, 0x00, 0x00, 0x00 }, //   ( 27)  ; - 0x003B Semicolon
				{ 0x08, 0x14, 0x22, 0x41, 0x00, 0x00 }, //   ( 28)  < - 0x003C Less-Than Sign
				{ 0x14, 0x14, 0x14, 0x14, 0x14, 0x00 }, //   ( 29)  = - 0x003D Equals Sign
				{ 0x00, 0x41, 0x22, 0x14, 0x08, 0x00 }, //   ( 30)  > - 0x003E Greater-Than Sign
				{ 0x02, 0x01, 0x51, 0x09, 0x06, 0x00 }, //   ( 31)  ? - 0x003F Question Mark
				{ 0x32, 0x49, 0x79, 0x41, 0x3E, 0x00 }, //   ( 32)  @ - 0x0040 Commercial At
				{ 0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00 }, //   ( 33)  A - 0x0041 Latin Capital Letter A
				{ 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00 }, //   ( 34)  B - 0x0042 Latin Capital Letter B
				{ 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00 }, //   ( 35)  C - 0x0043 Latin Capital Letter C
				{ 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00 }, //   ( 36)  D - 0x0044 Latin Capital Letter D
				{ 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00 }, //   ( 37)  E - 0x0045 Latin Capital Letter E
				{ 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00 }, //   ( 38)  F - 0x0046 Latin Capital Letter F
				{ 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00 }, //   ( 39)  G - 0x0047 Latin Capital Letter G
				{ 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00 }, //   ( 40)  H - 0x0048 Latin Capital Letter H
				{ 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00 }, //   ( 41)  I - 0x0049 Latin Capital Letter I
				{ 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00 }, //   ( 42)  J - 0x004A Latin Capital Letter J
				{ 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00 }, //   ( 43)  K - 0x004B Latin Capital Letter K
				{ 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00 }, //   ( 44)  L - 0x004C Latin Capital Letter L
				{ 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00 }, //   ( 45)  M - 0x004D Latin Capital Letter M
				{ 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00 }, //   ( 46)  N - 0x004E Latin Capital Letter N
				{ 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00 }, //   ( 47)  O - 0x004F Latin Capital Letter O
				{ 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00 }, //   ( 48)  P - 0x0050 Latin Capital Letter P
				{ 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00 }, //   ( 49)  Q - 0x0051 Latin Capital Letter Q
				{ 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00 }, //   ( 50)  R - 0x0052 Latin Capital Letter R
				{ 0x46, 0x49, 0x49, 0x49, 0x31, 0x00 }, //   ( 51)  S - 0x0053 Latin Capital Letter S
				{ 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00 }, //   ( 52)  T - 0x0054 Latin Capital Letter T
				{ 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00 }, //   ( 53)  U - 0x0055 Latin Capital Letter U
				{ 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00 }, //   ( 54)  V - 0x0056 Latin Capital Letter V
				{ 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00 }, //   ( 55)  W - 0x0057 Latin Capital Letter W
				{ 0x63, 0x14, 0x08, 0x14, 0x63, 0x00 }, //   ( 56)  X - 0x0058 Latin Capital Letter X
				{ 0x07, 0x08, 0x70, 0x08, 0x07, 0x00 }, //   ( 57)  Y - 0x0059 Latin Capital Letter Y
				{ 0x61, 0x51, 0x49, 0x45, 0x43, 0x00 }, //   ( 58)  Z - 0x005A Latin Capital Letter Z
				{ 0x00, 0x7F, 0x41, 0x41, 0x00, 0x00 }, //   ( 59)  [ - 0x005B Left Square Bracket
				{ 0x02, 0x04, 0x08, 0x10, 0x20, 0x00 }, //   ( 60)  \ - 0x005C Reverse Solidus
				{ 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00 }, //   ( 61)  ] - 0x005D Right Square Bracket
				{ 0x04, 0x02, 0x01, 0x02, 0x04, 0x00 }, //   ( 62)  ^ - 0x005E Circumflex Accent
				{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x00 }, //   ( 63)  _ - 0x005F Low Line
				{ 0x01, 0x02, 0x04, 0x00, 0x00, 0x00 }, //   ( 64)  ` - 0x0060 Grave Accent
				{ 0x20, 0x54, 0x54, 0x54, 0x78, 0x00 }, //   ( 65)  a - 0x0061 Latin Small Letter A
				{ 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00 }, //   ( 66)  b - 0x0062 Latin Small Letter B
				{ 0x38, 0x44, 0x44, 0x44, 0x20, 0x00 }, //   ( 67)  c - 0x0063 Latin Small Letter C
				{ 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00 }, //   ( 68)  d - 0x0064 Latin Small Letter D
				{ 0x38, 0x54, 0x54, 0x54, 0x18, 0x00 }, //   ( 69)  e - 0x0065 Latin Small Letter E
				{ 0x08, 0x7E, 0x09, 0x01, 0x02, 0x00 }, //   ( 70)  f - 0x0066 Latin Small Letter F
				{ 0x06, 0x49, 0x49, 0x49, 0x3F, 0x00 }, //   ( 71)  g - 0x0067 Latin Small Letter G
				{ 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00 }, //   ( 72)  h - 0x0068 Latin Small Letter H
				{ 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00 }, //   ( 73)  i - 0x0069 Latin Small Letter I
				{ 0x20, 0x40, 0x44, 0x3D, 0x00, 0x00 }, //   ( 74)  j - 0x006A Latin Small Letter J
				{ 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00 }, //   ( 75)  k - 0x006B Latin Small Letter K
				{ 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00 }, //   ( 76)  l - 0x006C Latin Small Letter L
				{ 0x7C, 0x04, 0x18, 0x04, 0x7C, 0x00 }, //   ( 77)  m - 0x006D Latin Small Letter M
				{ 0x7C, 0x08, 0x04, 0x04, 0x78, 0x00 }, //   ( 78)  n - 0x006E Latin Small Letter N
				{ 0x38, 0x44, 0x44, 0x44, 0x38, 0x00 }, //   ( 79)  o - 0x006F Latin Small Letter O
				{ 0x7C, 0x14, 0x14, 0x14, 0x08, 0x00 }, //   ( 80)  p - 0x0070 Latin Small Letter P
				{ 0x08, 0x14, 0x14, 0x18, 0x7C, 0x00 }, //   ( 81)  q - 0x0071 Latin Small Letter Q
				{ 0x7C, 0x08, 0x04, 0x04, 0x08, 0x00 }, //   ( 82)  r - 0x0072 Latin Small Letter R
				{ 0x48, 0x54, 0x54, 0x54, 0x20, 0x00 }, //   ( 83)  s - 0x0073 Latin Small Letter S
				{ 0x04, 0x3F, 0x44, 0x40, 0x20, 0x00 }, //   ( 84)  t - 0x0074 Latin Small Letter T
				{ 0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00 }, //   ( 85)  u - 0x0075 Latin Small Letter U
				{ 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00 }, //   ( 86)  v - 0x0076 Latin Small Letter V
				{ 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00 }, //   ( 87)  w - 0x0077 Latin Small Letter W
				{ 0x44, 0x28, 0x10, 0x28, 0x44, 0x00 }, //   ( 88)  x - 0x0078 Latin Small Letter X
				{ 0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00 }, //   ( 89)  y - 0x0079 Latin Small Letter Y
				{ 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00 }, //   ( 90)  z - 0x007A Latin Small Letter Z
				{ 0x00, 0x08, 0x36, 0x41, 0x00, 0x00 }, //   ( 91)  { - 0x007B Left Curly Bracket
				{ 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00 }, //   ( 92)  | - 0x007C Vertical Line
				{ 0x00, 0x41, 0x36, 0x08, 0x00, 0x00 }, //   ( 93)  } - 0x007D Right Curly Bracket
				{ 0x02, 0x01, 0x02, 0x04, 0x02, 0x00 }, //   ( 94)  ~ - 0x007E Tilde
				{ 0x3E, 0x55, 0x55, 0x41, 0x22, 0x00 }, //   ( 95)  C - 0x0080 <Control>
				{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, //   ( 96)    - 0x00A0 No-Break Space
				{ 0x00, 0x00, 0x79, 0x00, 0x00, 0x00 }, //   ( 97)  ! - 0x00A1 Inverted Exclamation Mark
				{ 0x18, 0x24, 0x74, 0x2E, 0x24, 0x00 }, //   ( 98)  c - 0x00A2 Cent Sign
				{ 0x48, 0x7E, 0x49, 0x42, 0x40, 0x00 }, //   ( 99)  L - 0x00A3 Pound Sign
				{ 0x5D, 0x22, 0x22, 0x22, 0x5D, 0x00 }, //   (100)  o - 0x00A4 Currency Sign
				{ 0x15, 0x16, 0x7C, 0x16, 0x15, 0x00 }, //   (101)  Y - 0x00A5 Yen Sign
				{ 0x00, 0x00, 0x77, 0x00, 0x00, 0x00 }, //   (102)  | - 0x00A6 Broken Bar
				{ 0x0A, 0x55, 0x55, 0x55, 0x28, 0x00 }, //   (103)    - 0x00A7 Section Sign
				{ 0x00, 0x01, 0x00, 0x01, 0x00, 0x00 }, //   (104)  " - 0x00A8 Diaeresis
				{ 0x00, 0x0A, 0x0D, 0x0A, 0x04, 0x00 }, //   (105)    - 0x00AA Feminine Ordinal Indicator
				{ 0x08, 0x14, 0x2A, 0x14, 0x22, 0x00 }, //   (106) << - 0x00AB Left-Pointing Double Angle Quotation Mark
				{ 0x04, 0x04, 0x04, 0x04, 0x1C, 0x00 }, //   (107)    - 0x00AC Not Sign
				{ 0x00, 0x08, 0x08, 0x08, 0x00, 0x00 }, //   (108)  - - 0x00AD Soft Hyphen
				{ 0x01, 0x01, 0x01, 0x01, 0x01, 0x00 }, //   (109)    - 0x00AF Macron
				{ 0x00, 0x02, 0x05, 0x02, 0x00, 0x00 }, //   (110)    - 0x00B0 Degree Sign
				{ 0x44, 0x44, 0x5F, 0x44, 0x44, 0x00 }, //   (111) +- - 0x00B1 Plus-Minus Sign
				{ 0x00, 0x00, 0x04, 0x02, 0x01, 0x00 }, //   (112)  ` - 0x00B4 Acute Accent
				{ 0x7E, 0x20, 0x20, 0x10, 0x3E, 0x00 }, //   (113)  u - 0x00B5 Micro Sign
				{ 0x06, 0x0F, 0x7F, 0x00, 0x7F, 0x00 }, //   (114)    - 0x00B6 Pilcrow Sign
				{ 0x00, 0x18, 0x18, 0x00, 0x00, 0x00 }, //   (115)  . - 0x00B7 Middle Dot
				{ 0x00, 0x40, 0x50, 0x20, 0x00, 0x00 }, //   (116)    - 0x00B8 Cedilla
				{ 0x00, 0x0A, 0x0D, 0x0A, 0x00, 0x00 }, //   (117)    - 0x00BA Masculine Ordinal Indicator
				{ 0x22, 0x14, 0x2A, 0x14, 0x08, 0x00 }, //   (118) >> - 0x00BB Right-Pointing Double Angle Quotation Mark
				{ 0x17, 0x08, 0x34, 0x2A, 0x7D, 0x00 }, //   (119) /4 - 0x00BC Vulgar Fraction One Quarter
				{ 0x17, 0x08, 0x04, 0x6A, 0x59, 0x00 }, //   (120) /2 - 0x00BD Vulgar Fraction One Half
				{ 0x30, 0x48, 0x45, 0x40, 0x20, 0x00 }, //   (121)  ? - 0x00BF Inverted Question Mark
		};

//______________________________________________________________________________________________

// OLED

void OLEDClear(void);

void OLEDSend(uint8 command) {
	sioWrite(1, OLED_address, 0x80, (uint8) command);
}

void i2c_OLED_send_byte(uint8 val) {
	sioWrite(1, OLED_address, 0x40, (uint8) val);
}

void OLEDInit(void) {
	OLEDSend(0xae); //display off
	OLEDSend(0xa4); //SET All pixels OFF
	//  OLEDSend(0xa5);            //SET ALL pixels ON
	Delay1mS(50);
	OLEDSend(0x20); //Set Memory Addressing Mode
	OLEDSend(0x02); //Set Memory Addressing Mode to Page addressing mode(RESET)
	//  OLEDSend(0xa0);      //colum address 0 mapped to SEG0 (POR)*** wires at bottom
	OLEDSend(0xa1); //colum address 127 mapped to SEG0 (POR) ** wires at top of board
	//  OLEDSend(0xC0);            // Scan from Right to Left (POR)         *** wires at bottom
	OLEDSend(0xC8); // Scan from Left to Right               ** wires at top
	OLEDSend(0xa6); // Set WHITE chars on BLACK backround
	//  OLEDSend(0xa7);            // Set BLACK chars on WHITE backround
	OLEDSend(0x81); // Setup CONTRAST CONTROL, following byte is the contrast Value
	OLEDSend(0xaf); // contrast value between 1 ( == dull) to 256 ( == bright)
	Delay1mS(20);
	OLEDSend(0xaf); //display on
	Delay1mS(20);
}

void OLEDSend2(uint8 ascii) {
	uint8 i;

	for (i = 0; i < 6; i++) {
		//zzz    buffer = pgm_read_byte(&(myFont[ascii - 32][i])); // call the macro to read ROM byte and put it in buffer
		buffer ^= CHAR_FORMAT; // apply
		i2c_OLED_send_byte(buffer);
	}
}

void OLEDSendString(const char *s) { // Sends a string of chars until null terminator
	uint8 i = 0;

	while (*s) {
		for (i = 0; i < 6; i++) {
			buffer = pgm_read_byte(&(myFont[(*s) - 32][i])); // call the macro to read the ROM ASCII table
			buffer ^= CHAR_FORMAT;
			i2c_OLED_send_byte((uint8) buffer);
		}
		*s++;
	}
}

void OLEDSendLogo(void) {
	int16 i, j;

	OLEDSend(0xa6); //Set Normal Display
	OLEDSend(0xae); // Display OFF
	OLEDSend(0x20); // Set Memory Addressing Mode
	OLEDSend(0x00); // Set Memory Addressing Mode to Horizontal addressing mode
	OLEDSend(0xb0); // set page address to 0
	OLEDSend(0X40); // Display start line register to 0
	OLEDSend(0); // Set low col address to 0
	OLEDSend(0x10); // Set high col address to 0
	for (i = 0; i < 1024; i++) { // fill the display's RAM with graphic... 128*64 pixel picture
		//zzz   buffer = pgm_read_byte(&(LOGO[i]));
		i2c_OLED_send_byte(buffer);
	}
	OLEDSend(0x81); // Setup CONTRAST CONTROL, following byte is the contrast Value... always a 2 byte instruction
	OLEDSend(0x0); // Set contrast value to 0
	OLEDSend(0xaf); // display on
	for (j = 0; j < 2; j++) {
		for (i = 0x01; i < 0xff; i++) {
			OLEDSend(0x81); // Setup CONTRAST CONTROL, following byte is the contrast Value
			OLEDSend(i); // Set contrast value
			Delay1mS(1);
		}
		for (i = 0xff; i > 0x01; i--) {
			OLEDSend(0x81); // Setup CONTRAST CONTROL, following byte is the contrast Value
			OLEDSend(i); // Set contrast value
			Delay1mS(1);
		}
	}
	OLEDInit();
	OLEDClear();
}

void OLEDLogo(void) {
	uint8 i;

	OLEDSend(0xa6); //Set Normal Display
	OLEDSend(0xae); // Display OFF
	OLEDSend(0x20); // Set Memory Addressing Mode
	OLEDSend(0x00); // Set Memory Addressing Mode to Horizontal addressing mode
	OLEDSend(0xb0); // set page address to 0
	OLEDSend(0X40); // Display start line register to 0
	OLEDSend(0); // Set low col address to 0
	OLEDSend(0x10); // Set high col address to 0
	for (i = 0; i < 1024; i++) { // fill the display's RAM with graphic... 128*64 pixel picture
		buffer = pgm_read_byte(&(LOGO[i]));
		i2c_OLED_send_byte(buffer);
	}
	OLEDSend(0x81); // Setup CONTRAST CONTROL, following byte is the contrast Value... always a 2 byte instruction
	OLEDSend(250); // Here you can set the brightness 1 = dull, 255 is very bright
	OLEDSend(0xaf); // display on
}

void OLEDCursor(uint8 col, uint8 row) { //  Not used in MW V2.0 but its here anyway!
	OLEDSend(0xb0 + row); //set page address
	OLEDSend(0x00 + (8 * col & 0x0f)); //set low col address
	OLEDSend(0x10 + ((8 * col >> 4) & 0x0f)); //set high col address
}

void OLEDClear(void) {
	//  uint8 i;
	//  for(i=0;i<8;i++){
	//    OLEDCursor(0,i);
	//    OLEDSendString(LINE_FILL_STRING);
	//  }
	uint16 i;

	OLEDSend(0xa6); //Set Normal Display
	OLEDSend(0xae); // Display OFF
	OLEDSend(0x20); // Set Memory Addressing Mode
	OLEDSend(0x00); // Set Memory Addressing Mode to Horizontal addressing mode
	OLEDSend(0xb0); // set page address to 0
	OLEDSend(0X40); // Display start line register to 0
	OLEDSend(0); // Set low col address to 0
	OLEDSend(0x10); // Set high col address to 0
	for (i = 0; i < 1024; i++) // fill the display's RAM with graphic... 128*64 pixel picture
		i2c_OLED_send_byte(0); // clear
	OLEDSend(0x81); // Setup CONTRAST CONTROL, following byte is the contrast Value... always a 2 byte instruction
	OLEDSend(200); // Here you can set the brightness 1 = dull, 255 is very bright
	OLEDSend(0xaf); // display on
}

//______________________________________________________________________________________________

// i2c Eagle Tree Power Panel

//	Ground - white
//	+5V VCC - red
//	SDA - yellow
//	SCL - brown

#define LCD_ETPP_ADDRESS (0x3B<<1)

static boolean charsInitialized; // chars for servo signals are initialized

void ETPPInit(void) {
	uint8 B[3] = { 0x24, 0x0c, 0x06 };

	//	0x24 Function Set 001D0MSL D : data length for parallel interface only; M: 0 = 1x32 , 1 = 2x16; S: 0 = 1:18 multiplex drive mode, 1x32 or 2x16 character display, 1 = 1:9 multiplex drive mode, 1x16 character display; H: 0 = basic instruction set plus standard instruction set, 1 = basic instruction set plus extended instruction set
	//	0x0C Display on   00001DCB D : 0 = Display Off, 1 = Display On; C : 0 = Underline Cursor Off, 1 = Underline Cursor On; B : 0 = Blinking Cursor Off, 1 = Blinking Cursor On
	//	0x06 Cursor Move  000001IS I : 0 = DDRAM or CGRAM address decrements by 1, cursor moves to the left, 1 = DDRAM or CGRAM address increments by 1, cursor moves to the right; S : 0 = display does not shift,  1 = display does shifts
	sioWriteBlock(SIOLCD, LCD_ETPP_ADDRESS, 0x00, 3, B);
	LCDClear();
} // ETPPInit

void ETPPSend(char c) {

	if (c > 0x0f)
		c |= 0x80; // LCD_ETPP uses character set "R", which has A->z mapped same as ascii + high bit; don't mess with custom chars.
	sioWrite(SIOLCD, LCD_ETPP_ADDRESS, 0x40, c);
} // ETPPSend

void ETPPCursor(uint8 col, uint8 row) {
	uint8 addr;

	row = Min(row, 1);
	col = Min(col, 15);
	addr = col + row * 0x40; // Why 0x40? RAM in this controller has many more bytes than are displayed.  In particular, the start of the second line (line 1 char 0) is 0x40 in DDRAM. The bytes between 0x0F (last char of line 1) and 0x40 are not displayable (unless the display is placed in marquee scroll mode)
	ETPPSend(0x80 | addr); // High bit is "Set DDRAM" command, remaining bits are addr.
}

void ETPPSendString(uint8 idx, uint8* s) {

	ETPPSend(0x80); // CGRAM and DDRAM share an address register, but you can't set certain bits with the CGRAM address command.
	// Use DDRAM address command to be sure high order address bits are zero.
	ETPPSend(0x40 | (uint8) (idx * 8));// Set CGRAM address

	sioWriteBlock(SIOLCD, LCD_ETPP_ADDRESS, 0x40, 8, s);

} // ETPPSendString


void ETPPBarGraph(uint8 num, int val) { // num chars in graph; percent as 1 to 100
	int8 i, j;
	static char bar[16];
	static uint8 bars[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, };
	static uint8 less[8] = { 0x00, 0x04, 0x0C, 0x1C, 0x0C, 0x04, 0x00, 0x15, };
	static uint8 grt[8] = { 0x00, 0x04, 0x06, 0x07, 0x06, 0x04, 0x00, 0x15, };
	uint8 pattern;

	if (!charsInitialized) {
		charsInitialized = true;

		pattern = 0x10;
		for (i = 0; i <= 5; i++) {
			for (j = 0; j < 7; j++)
				bars[j] = pattern;
			ETPPSendString(i, bars);
			pattern >>= 1;
		}
		ETPPSendString(6, less);
		ETPPSendString(7, grt);
	}

	for (i = 0; i < num; i++)
		bar[i] = 5;

	if (val < -100 || val > 100) {
		bar[0] = 6;
		bar[num] = 7;
	} // invalid
	else if (val < 0)
		bar[0] = 6;
	else if (val >= 100)
		bar[3] = 7;
	else
		bar[val / (100 / num)] = (val % (100 / num)) / 5;

	for (i = 0; i < num; i++)
		ETPPSend(bar[i]);

}

//______________________________________________________________________________________________

// LCD03

#define LCD_LCD03_ADDRESS (0x63 << 1)

void LCD03Init(void) {
	uint8 B[] = { 4, 12, 19 }; // Hide cursor, Clear screen, Backlight on

	sioWriteBlock(SIOLCD, LCD_LCD03_ADDRESS, 0x00, 3, B);
} // LCD03Init

void LCD03Send(char c) {
	sioWrite(SIOLCD, LCD_LCD03_ADDRESS, 0x00, c);
} // LCD03Send

void LCD03Cursor(uint8 col, uint8 row) {
	row = Min(row, 1);
	col = Min(col, 15);
	LCD03Send(03); // set cursor (row, column)
	LCD03Send(row + 1);
	LCD03Send(col + 1);
} // LCD03Cursor

//------------------------------------------------------------------

void LCDSend(uint8 i) {
	uint8 mask;

	switch (LCDType) {
	case LCD_SERIAL3W:
		// 1000000 / 9600  = 104 microseconds at 9600 baud.
		// we set it below to take some margin with the running interrupts
#define BITDELAY 102
		LCDPIN_OFF;
		Delay1uS(BITDELAY);
		for (mask = 0x01; mask; mask <<= 1) {
			if (i & mask) {
				LCDPIN_ON;
			} else {
				LCDPIN_OFF;
			} // choose bit
			Delay1uS(BITDELAY);
		}
		LCDPIN_ON //switch ON digital PIN 0
		Delay1uS(BITDELAY);
		break;
	case LCD_TEXTSTAR:
	case LCD_VT100:
		TxChar(TelemetrySerial, i);
		break;
	case LCD_ETPP:
		ETPPSend(i);
		break;
	case LCD_LCD03:
		LCD03Send(i);
		break;
	case OLED_I2C_128x64:
		OLEDSend(i);
		break;
	default:
		break;
	}
}

void LCDSendString(const char *s) {
	while (*s)
		LCDSend(*s++);
}

void LCDNextLine() {
	if (LCDType != OLED_I2C_128x64)
		LCDSendString("\r\n");
}

void LCDClear() {
	uint8 i;

	switch (LCDType) {
	case LCD_SERIAL3W:
		LCDSend(0xFE);
		LCDSend(0x01);
		Delay1mS(10);
		LCDSend(0xFE);
		LCDSend(0x02);
		Delay1mS(10); // clear screen, cursor line 1, pos 0 for serial LCD Sparkfun - contrib by flyman777
		break;
	case LCD_TEXTSTAR:
		LCDSend(0x0c);
		break;
	case LCD_VT100:
		LCDNextLine();
		LCDSend(0x1B);
		LCDSend(0x5B);
		LCDSendString("2J"); //ED2
		LCDNextLine();
		LCDSend(0x1B);
		LCDSend(0x5B);
		LCDSendString("1;1H");//cursor top left
		break;
	case LCD_ETPP:
		ETPPSend(0x01); // Clear display command, which does NOT clear an Eagle Tree because character set "R" has a '>' at 0x20
		for (i = 0; i < 80; i++)
			ETPPSend(' ');// Blanks for all 80 bytes of RAM in the controller, not just the 2x16 display
		break;
	case LCD_LCD03:
		LCD03Send(12); // clear screen
		break;
	case OLED_I2C_128x64:
		OLEDClear();
		break;
	default:
		break;
	} // switch
}

void LCDsetLine(uint8 line) { // Line = 1 or 2 - vt100 has lines 1-99
	switch (LCDType) {
	case LCD_SERIAL3W:
		if (line == 1) {
			LCDSend(0xFE);
			LCDSend(128);
		} else {
			LCDSend(0xFE);
			LCDSend(192);
		}
		break;
	case LCD_TEXTSTAR:
		LCDNextLine();
		LCDSend(0xfe);
		LCDSend('L');
		LCDSend(line);
		break;
	case LCD_VT100:
		if (!DEBUG) // sanity check for production only. Debug runs with all possible side effects
			if (line < 1 || line > (MULTILINE_PRE + MULTILINE_POST))
				line = 1;
		LCDNextLine();
		LCDSend(0x1b);
		LCDSend(0x5b);
		/*zzz
		 LCDSend(digit10(line));
		 LCDSend(digit1(line));
		 */
		LCDSendString(";1H"); //pos line 1
		LCDSend(0x1b);
		LCDSend(0x5b);
		LCDSendString("2K");//EL2
		break;
	case LCD_ETPP:
		ETPPCursor(0, line - 1);
		break;
	case LCD_LCD03:
		LCD03Cursor(0, line - 1);
		break;
	case OLED_I2C_128x64:
		//#ifndef DEBUG // sanity check for production only. Debug runs with all possible side effects
		if (line < 1 || line > (MULTILINE_PRE + MULTILINE_POST))
			line = 1;
		//#endif
		OLEDCursor(0, line - 1);
		break;\

	default:
		break;
	}
}

void LCDattributesBold(void) {

	if (LCDType == LCD_VT100) {
		LCDSend(0x1b);
		LCDSend(0x5b);
		LCDSendString("1m");
	} else if (LCDType == OLED_I2C_128x64)
		CHAR_FORMAT = 0x7f;//0b01111111;
}

void LCDattributesReverse(void) {
	if (LCDType == LCD_VT100) {
		LCDSend(0x1b);
		LCDSend(0x5b);
		LCDSendString("7m");
	}
}

void LCDattributesOff(void) {
	if (LCDType == LCD_VT100) {
		LCDSend(0x1b);
		LCDSend(0x5b);
		LCDSendString("0m");
	} else if (LCDType == OLED_I2C_128x64)
		CHAR_FORMAT = 0;
}

#define LCD_FLUSH {/*UartSendData();*/ Delay1uS(20000); }

void LCDSendi16(int16 v) {
	uint16 unit;
	char line[7] = "      ";
	if (v < 0) {
		unit = -v;
		line[0] = '-';
	} else {
		unit = v;
		line[0] = ' ';
	}
	Insert(&line[1], unit, 5);
	LCDSendString(line);
}

void LCDInit(void) {

	//zzz blinkLED(20, 30, 1);

	switch (LCDType) {
	case LCD_SERIAL3W:
		//SerialEnd(0);
		//init LCD
		PINMODE_LCD;//TX PIN for LCD = Arduino RX PIN (more convenient to connect a servo plug on arduino pro mini)
		break;
	case LCD_TEXTSTAR:
		// Cat's Whisker Technologies 'TextStar' Module CW-LCD-02
		// http://cats-whisker.com/resources/documents/cw-lcd-02_datasheet.pdf
		LCDSend(0xFE);
		LCDSend(0x43);
		LCDSend(0x02); //cursor blink mode
		LCDSend(0xFE);
		LCDSend('R');//reset
		break;
	case LCD_VT100:
		LCDSend(0x1b);
		LCDSend('c'); //RIS
		Delay1mS(2500);
		LCDClear();
		break;
	case LCD_ETPP:
		// Eagle Tree Power Panel - I2C & Daylight Readable LCD
		ETPPInit();
		break;
	case LCD_LCD03:
		// LCD03 - I2C LCD
		// http://www.robot-electronics.co.uk/htm/Lcd03tech.htm
		LCD03Init();
		break;
	case OLED_I2C_128x64:
		OLEDInit();
		OLEDClear();

		Insert(&L[0][10], VERSION, 3);
		LCDattributesBold();
		OLEDCursor(0, 0);
		LCDSendString(L[0]);

		//LCDattributesBold();
		LCDsetLine(2);
		LCDSendString(L[1]);
		LCDattributesOff();
		//#endif // OLED_I2C_128x64LOGO_PERMANENT
		break;
	}
	//#endif
#if defined(OLED_I2C_128x64) && !(defined(OLED_I2C_128x64LOGO_PERMANENT)) && defined(NEW_OLED_FONT) && !(defined(LCD_TELEMETRY))
	// no need to diplay this, if LCD telemetry is enabled
	//   optional instruction on the display......
	LCDsetLine(4); LCDSendString("To ENTER CONFIG      ");// 21 characters on each line
	LCDsetLine(5); LCDSendString("YAW RIGHT & PITCH FWD");
	LCDsetLine(7); LCDSendString("To SAVE CONFIG       ");
	LCDsetLine(8); LCDSendString("YAW LEFT & PITCH FWD ");
#endif

}

//______________________________________________________________________________________________


// Two Line LCD

void ConfigRefresh2(uint8 p) {
	//LCDParamStruct* deft;

	blinkLED(10, 20, 1);
	//strcpy_P(L[0], PSTR("                "));
	//strcpy(L[1], L[0]);
	//strcpy_P(L[0], (char*) pgm_read_word(&(lcd_param_ptrable[p * 3])));
	//deft = (LCDParamStruct*) pgm_read_word(&(lcd_param_ptrable[(p * 3) + 2]));
	//deft->type->fmt((void*) pgm_read_word(&(lcd_param_ptrable[(p * 3) + 1])),
	//		deft->multiplier, deft->decimal);
	LCDClear();
	LCDCursor(0, 0);
	LCDSendString(L[0]); //refresh line 1 of LCD
	LCDCursor(1, 0);
	LCDSendString(L[1]);//refresh line 2 of LCD
}

//______________________________________________________________________________________________

// Multiline LCD

// display slice of config items prior and after current item (index p)

void ConfigRefresh(uint8 p) {
	//LCDParamStruct* deft;
	uint8 j, l = 1;
	int8 i;
	int8 pp = (int8) p;

	if (LCDType == OLED_I2C_128x64) {
		blinkLED(2, 4, 1);
		LCDClear();
	} else
		Delay1mS(60);

	for (i = pp - MULTILINE_PRE; i < pp + MULTILINE_POST; i++) {
		//j = i % (1+MAX_PARAMS); // why does modulo not work here?
		j = (i < 0 ? i + 1 + MAX_PARAMS : i);
		if (j > MAX_PARAMS)
			j -= (1 + MAX_PARAMS);
		//strcpy_P(L[0], PSTR("          "));
		//strcpy(L[1], L[0]);
		//strcpy_P(L[0], (char*) pgm_read_word(&(lcd_param_ptrable[j * 3])));
		//deft = (LCDParamStruct*) pgm_read_word(
		//		&(lcd_param_ptrable[(j * 3) + 2]));
		//deft->type->fmt(
		//		(void*) pgm_read_word(&(lcd_param_ptrable[(j * 3) + 1])),
		//		deft->multiplier, deft->decimal);

		LCDsetLine(l++);
		if (j == p) {
#ifndef OLED_I2C_128x64
			LCDSend('>');
#endif
			LCDattributesReverse();
		}
		LCDSendString(L[0]); // the label
		if (j == p) {
			LCDattributesOff(); /*LCDattributesBold();*/
		}
		//LCDSend(' ');
		LCDSendString(L[1]); // the value
#ifndef OLED_I2C_128x64
		if (j == p) {
			LCDattributesOff();
			LCDSend('<');
		}
#endif
		LCD_FLUSH;
	}
	LCDNextLine();
}

void configurationLoop(void) {
	uint8 i, p;
	uint8 LCD = 1;
	uint8 RefreshLCD = true;
	uint8 key = 0;
//	LCDParamStruct* deft;
#ifndef OLED_I2C_128x64
	LCDInit();
#endif
#if defined OLED_I2C_128x64LOGO_PERMANENT
	LCDclear();
#endif
	Delay1mS(500);
	p = 0;
	while (LCD == 1) {
		if (RefreshLCD) {
			ConfigRefresh(p);
			RefreshLCD = false;
		}

#if defined(LCD_TEXTSTAR) || defined(LCD_VT100) // textstar or vt100 can send keys
		key = ( SerialAvailable(0) ? SerialRead(0) : 0 );
#endif
#if defined(LCD_CONF_DEBUG)
		Delay1mS(1000);
		if (key == LCD_MENU_NEXT) key=LCD_VALUE_UP; else key = LCD_MENU_NEXT;
#endif
		for (i = ROLL; i < THROTTLE; i++) {
			uint16 Tmp = readRawRC(i);
			lcdStickState[i] = (Tmp < MINCHECK) | ((Tmp > MAXCHECK) << 1);
		};
		if (key == LCD_MENU_SAVE_EXIT || (IsLow(YAW) && IsHigh(PITCH)))
			LCD = 0; // save and exit
		else if (key == LCD_MENU_ABORT || (IsHigh(YAW) && IsHigh(PITCH)))
			LCD = 2;// exit without save: eeprom has only 100.000 write cycles
		else if (key == LCD_MENU_NEXT || (IsLow(PITCH))) { //switch config param with pitch
			RefreshLCD = true;
			p++;
			if (p > MAX_PARAMS)
				p = 0;
		} else if (key == LCD_MENU_PREV || (IsHigh(PITCH))) {
			RefreshLCD = true;
			p--;
			if (p == 0xFF)
				p = MAX_PARAMS;
		} else if (key == LCD_VALUE_DOWN || (IsLow(ROLL))) { //+ or - param with low and high roll
			RefreshLCD = true;
			//deft = (LCDParamStruct*) pgm_read_word(&(lcd_param_ptrable[(p * 3)
			//		+ 2]));
			//deft->type->inc((void*) pgm_read_word(&(lcd_param_ptrable[(p * 3)
			//		+ 1])), -deft->increment);
			//if (p == 0)
			//	conf.P8[PITCH] = conf.P8[ROLL];
		} else if (key == LCD_VALUE_UP || (IsHigh(ROLL))) {
			RefreshLCD = true;
			//deft = (LCDParamStruct*) pgm_read_word(&(lcd_param_ptrable[(p * 3)
			//		+ 2]));
			//deft->type->inc((void*) pgm_read_word(&(lcd_param_ptrable[(p * 3)
			//		+ 1])), +deft->increment);
			//	if (p == 0)
			//		conf.P8[PITCH] = conf.P8[ROLL];
		}
	} // while (LCD == 1)
	blinkLED(20, 30, 1);

	LCDClear();
	LCDCursor(0, 0);
	if (LCD == 0) {
		strcpy_P(L[0], PSTR("Saving..."));
		LCDSendString(L[0]);
		//zzz	writeParams(1);
	} else {
		strcpy_P(L[0], PSTR("Aborting"));
		LCDSendString(L[0]);
	}

	LCDCursor(0, 0);
	strcpy_P(L[0], PSTR("Exit"));
	LCDSendString(L[0]);

	if (LCDType == LCD_LCD03) {
		Delay1mS(2000); // wait for two seconds then clear screen and show initial message
		LCDInit();
	} else if (LCDType == LCD_SERIAL3W)
		serialBaudRate(TelemetrySerial, LCD_BAUD_RATE);

	if (LCD_TELEMETRY)
		Delay1mS(1500); // keep exit message visible for one and one half seconds even if (auto)telemetry continues writing in main loop

	if (LCDType == OLED_I2C_128x64) {
		Delay1mS(2000); // wait for two seconds then clear screen and show initial message
		cycleTime = 0;
	}

	if (OLED_I2C_128x64LOGO_PERMANENT)
		OLEDLogo();
	else
		LCDClear();
}

#endif // USE_LCD
